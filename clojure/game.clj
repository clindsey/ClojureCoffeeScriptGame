(ns physicsGame)
(def jquery (js* "$"))
; Box2d Imports: Generated by macro.clj
(def b2AABB js/Box2D.Collision.b2AABB)
(def b2BodyDef js/Box2D.Dynamics.b2BodyDef)
(def b2Body js/Box2D.Dynamics.b2Body)
(def b2FixtureDef js/Box2D.Dynamics.b2FixtureDef)
(def b2Fixture js/Box2D.Dynamics.b2Fixture)
(def b2World js/Box2D.Dynamics.b2World)
(def b2DebugDraw js/Box2D.Dynamics.b2DebugDraw)
(def b2PolygonShape js/Box2D.Collision.Shapes.b2PolygonShape)
(def b2CircleShape js/Box2D.Collision.Shapes.b2CircleShape)

(defn v [x y] (js/Box2D.Common.Math.b2Vec2. x y))
(defn dom [s] (->> (name s) (str "#") jquery))

; Using set! is really verbose, and doesn't accept anything other than bare symbols
(def nativejsset (js* "function (o, key ,val) {
   o[key] = val;
}"))

(defn native-set-wrapper [jsobject attr value]
  (nativejsset jsobject (name attr) value)
  )
(defn js-set
  "Sets an attribute name to a value on a javascript object
  Returns the original object"
  ([jsobject attr value]
    (do
      (native-set-wrapper jsobject attr value)
      jsobject
      )
    )
  ([jsobject & values]
    (do
      (doseq [[attr value] (apply hash-map values)]
        (native-set-wrapper jsobject attr value)
        )
      jsobject
      )
    )
  )

(defn atom-set
  "Helper function for setting an atom of a map"
  [atom & values]
  (swap! atom #(apply assoc % values))
  )

(def)

(def p js/puts)
(def W)
(def H)
(def scale 30)
(def speed-rate 300)

(defn get-canvas []
  (let [canvas (dom :canvas)]
    (def W (. canvas (width)))
    (def H (. canvas (height)))
    (.get canvas 0)
    )
  )

(defn create-game [canvas]
  (let [gravity (v 0 10)
        doSleep false
        twiceScale (* 2 scale)]
    (init (atom
      {:center-x (/ W twiceScale)
       :center-y (/ H twiceScale)
       :world (b2World. gravity doSleep)
       :canvas canvas
       }

      ))
    ))

(defn init [game]
  (atom-set game
    :to-destroy []
    :paused false
    :game-over false
    :score 0
    :speed 0
    :ticks-to-speed speed-rate

    )
  )

(defn add-methods [game-ref]
  (assoc game-ref
    :create-circle create-circle
    )
  )


;  (set! (. f density) 3) is ugly. Lack of macros/eval make this impossible to solve without native javascript
(defn create-fixture
  ([shape] (js-set (b2FixtureDef.)
             :density 3
             :friction 0.3
             :restitution 0.9
             :shape shape
             ))
  ([] (create-fixture nil))
  )

(defn create-body [x y]
  (let [b (b2BodyDef.)]
    (js-set b :type (.b2_dynamicBody b2Body))
    (-> (.position b) (.Set x y))
    b
    ))

(defn create [game body-def fix-def]
  (let [body (-> (@game :world) (.CreateBody body-def))]
    (.CreateFixture body fix-def)
    body
    )
  )

(defn wall
  ([game width height x y] (wall game width height x y nil))
  ([game width height x y user-data]
    (let [fix-def (create-fixture (b2PolygonShape.))
          body-def (create-body x y)]
      (-> (.shape fix-def) (.SetAsBox width height))
      (js-set body-def
        :userData (name user-data)
        :type (.b2_staticBody b2Body))
      (create game body-def fix-def))
    ))


(defn build-walls [game]
  (let [w (@game :center-x)
        h (@game :center-y)
        dim (/ 200 scale)]
    (wall game w dim w (- dim) :ceiling)
    (wall game w dim w (+ dim (* 2 h)))
    (wall game dim h (- dim) h)
    (wall game dim h (+ dim (* 2 w)) h)
    )
  )

(defn random-body [x y]
  (let [b (create-body x y)
        vx (- (* 10 (rand)) 5)]
    (js-set b :angle (* 360 (rand))
      :linearVelocity (v vx 0)
      :angularVelocity (- (* 4 (rand)) 2)
      )
    ))

(defn create-circle [game x y size]
  (create game (random-body x y) (create-fixture (b2CircleShape. size)))
  )

(defn create-element [game]
  (let [randomY (/ (* H (+ 0.2 (* 0.4 (rand)))) scale)
        randomX (/ (+ 25 (* (rand) (- W 50))) scale)]
    (create-circle game randomX randomY (inc (rand)))
    )
  )

(defn maybe-create-element [game]
  (let [neg-probability (* 0.97 (Math/pow 0.95, (@game :speed)))]
    (if (> (rand) neg-probability) (create-element game))
    )
  )

(defn tick [game]
  (let [w (@game :world)]
    (maybe-create-element game)
    (.Step w (/ 1 30) 10 10)
    (. w (DrawDebugData))
    (. w (ClearForces))
    ))

(defn animate-world [game]
  (let [debug-draw (b2DebugDraw.)]
    (doto debug-draw
      (.SetSprite (-> (@game :canvas) (.getContext "2d")))
      (.SetDrawScale scale)
      (.SetLineThickness 1.0)
      (.SetFlags (.e_shapeBit b2DebugDraw))
      )
    (-> (@game :world) (.SetDebugDraw debug-draw))
    (js/setInterval #(tick game) (/ 1000 30))
    ))


(defn init-web-app []
  (let [game (create-game (get-canvas))]
    (build-walls game)
    (animate-world game)
    ))

(jquery init-web-app)

(defn redfn [r [k v]]
  (assoc r k (apply f v args))
  )

